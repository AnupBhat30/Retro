import streamlit as st
import google.generativeai as genai
import os
import random
import json
from dotenv import load_dotenv
import re # Import regex for cleaning potential JSON issues

# --- Configuration & Setup ---

# Load environment variables (for API Key)
load_dotenv()
GOOGLE_API_KEY = os.environ.get("GOOGLE_API_KEY")

# Configure Google Generative AI
if not GOOGLE_API_KEY:
    st.error("‚ö†Ô∏è Google API Key not found. Please set the GOOGLE_API_KEY environment variable in a .env file or Streamlit secrets.")
    st.stop()

try:
    genai.configure(api_key=GOOGLE_API_KEY)
    # Specify flash model explicitly
    LLM_MODEL = "gemini-2.0-flash-exp" 
    # Configuration for JSON output (more reliable)
    json_generation_config = genai.GenerationConfig(response_mime_type="application/json")
    # Standard config for text generation
    text_generation_config = genai.GenerationConfig(
        temperature=0.7,
        top_p=0.9,
        max_output_tokens=300
    )
    model_json = genai.GenerativeModel(LLM_MODEL, generation_config=json_generation_config)
    model_text = genai.GenerativeModel(LLM_MODEL, generation_config=text_generation_config)
    print("Google Generative AI configured successfully.")
except Exception as e:
    st.error(f"‚ö†Ô∏è Error configuring Google Generative AI: {e}")
    st.stop()


# --- Game Constants ---
STARTING_AGE = 21
STARTING_SAVINGS = 50000  # Rupees
INITIAL_JOB = "Entry-Level Analyst"
INITIAL_SALARY = 30000  # Monthly Rupees
INITIAL_EXPENSES = 15000 # Monthly Rupees
RETIREMENT_AGE = 60
INFLATION_RATE = 0.06 # Annual
INVESTMENT_RETURN_LOW_RISK = 0.07 # Annual (e.g., FD, PPF simulation)
INVESTMENT_RETURN_MED_RISK = 0.12 # Annual (e.g., Mutual Funds simulation)
INVESTMENT_RETURN_HIGH_RISK = 0.15 # Annual (e.g., Stocks simulation) - simplified

# --- Helper Functions ---

def initialize_game_state():
    """Creates the initial state dictionary for a new game."""
    return {
        "profile": {
            "name": "Player", # Could be customized later
            "age": STARTING_AGE,
        },
        "finances": {
            "savings_cash": STARTING_SAVINGS,
            "investments": {
                "ppf": 0,
                "mutual_funds": 0,
                "stocks": 0,
                "digital_gold": 0,
            },
            "loans": {}, # e.g., "home_loan": {"principal": 5000000, "interest_rate": 0.08, "emi": 40000}
            "income": INITIAL_SALARY,
            "expenses": INITIAL_EXPENSES, # Base monthly expenses
            "net_worth": STARTING_SAVINGS,
        },
        "career": {
            "job_title": INITIAL_JOB,
            "promotion_chance": 0.1, # Probability per year
            "experience_years": 0,
        },
        "assets": {
            "vehicle": None, # e.g., "Two-wheeler" or "Car"
            "property": None, # e.g., "Apartment"
        },
        "family": {
            "marital_status": "Single",
            "children": 0,
        },
        "life_stage": "Early Career",
        "financial_health_score": 50, # Starting score (out of 100)
        "game_log": [f"üöÄ Game Started! Age: {STARTING_AGE}, Savings: ‚Çπ{STARTING_SAVINGS:,.0f}"],
        "current_event": None, # To store the event details generated by LLM
        "last_decision_impact": "", # Feedback message after a choice
        "chat_history": [], # For ArthMitra AI Advisor
        "game_over": False
    }

def calculate_financial_health(state):
    """Calculates a simple financial health score."""
    score = 50
    # Ensure income is not zero before division
    if state["finances"]["income"] <= 0:
        savings_ratio = 0 
    else:
        savings_ratio = (state["finances"]["income"] - state["finances"]["expenses"]) / state["finances"]["income"]
        
    investment_total = sum(state["finances"]["investments"].values())
    net_worth = state["finances"]["net_worth"]

    if savings_ratio > 0.2: score += 15
    elif savings_ratio > 0.1: score += 5
    else: score -= 10

    if investment_total > state["finances"]["savings_cash"] * 2: score += 15
    elif investment_total > state["finances"]["savings_cash"]: score += 5

    if net_worth < 0: score -= 20 # High debt penalty
    elif net_worth > 1000000: score += 10 # Milestone bonus
    elif net_worth > 500000: score += 5

    # Emergency fund check (e.g., 3 months expenses in cash/low-risk)
    emergency_fund_target = state["finances"]["expenses"] * 3
    if state["finances"]["savings_cash"] >= emergency_fund_target:
        score += 10
    elif state["finances"]["savings_cash"] >= state["finances"]["expenses"]:
        score += 5
    else:
        score -= 5
        
    # Loan penalty (simplified)
    if state["finances"]["loans"]:
      score -= len(state["finances"]["loans"]) * 5 # Penalty per active loan

    return max(0, min(100, score)) # Clamp between 0 and 100

def update_net_worth(state):
    """Recalculates net worth."""
    investment_total = sum(state["finances"]["investments"].values())
    loan_total = sum(loan.get('principal', 0) for loan in state["finances"]["loans"].values()) # Use .get for safety
    state["finances"]["net_worth"] = state["finances"]["savings_cash"] + investment_total - loan_total
    # Add asset values later if implemented
    return state

def advance_year(state):
    """Simulates the passing of one year. Returns the updated state."""
    if state["game_over"]: return state # Don't advance if game over
    
    new_state = state.copy() # Avoid modifying original dict directly if passed by reference elsewhere
    new_state["profile"]["age"] += 1
    new_state["game_log"].append(f"--- Age {new_state['profile']['age']} ---")

    # 1. Apply Inflation to Expenses
    new_state["finances"]["expenses"] *= (1 + INFLATION_RATE)

    # 2. Earn Income & Pay Expenses (Monthly simulated over year)
    annual_income = new_state["finances"]["income"] * 12
    annual_expenses = new_state["finances"]["expenses"] * 12
    
    # Handle Loan EMIs 
    annual_emi_paid = 0
    interest_paid_total = 0
    loans_to_remove = []
    # Iterate over a copy of keys for safe deletion
    for loan_name, loan_details in list(new_state["finances"]["loans"].items()):
        if 'emi' in loan_details and 'principal' in loan_details and 'interest_rate' in loan_details:
            annual_payment = loan_details.get('emi', 0) * 12
            # Ensure principal exists and is positive before calculating interest
            if loan_details.get('principal', 0) > 0:
                annual_interest = loan_details['principal'] * loan_details.get('interest_rate', 0)
                principal_paid = annual_payment - annual_interest
                principal_paid = max(0, min(principal_paid, loan_details['principal'])) # Ensure valid payment
            else: # Principal is zero or negative, no more payments needed
                principal_paid = 0
                annual_payment = 0 # Don't account for EMI if principal is zero

            # Deduct principal paid
            if loan_details.get('principal', 0) > 0:
                loan_details['principal'] -= principal_paid
            
            annual_emi_paid += annual_payment
            interest_paid_total += max(0, annual_interest) # Interest shouldn't be negative

            if loan_details.get('principal', 0) <= 0:
                loans_to_remove.append(loan_name)
                new_state["game_log"].append(f"üéâ Paid off {loan_name.replace('_', ' ').title()}!")

    for loan_name in loans_to_remove:
        # Adjust expenses back down if EMI was part of it (simple removal)
        # More robust: track which expenses included EMI separately
        if 'emi' in new_state["finances"]["loans"][loan_name]:
             new_state["finances"]["expenses"] -= new_state["finances"]["loans"][loan_name].get('emi_expense_impact', new_state["finances"]["loans"][loan_name]['emi']) # Subtract the EMI added earlier
        del new_state["finances"]["loans"][loan_name]
        
    # Calculate net annual income after expenses and EMIs
    net_annual_income = annual_income - annual_expenses - annual_emi_paid
    new_state["finances"]["savings_cash"] += net_annual_income
    
    # Log financial summary for the year
    log_msg = (f"Yearly Income: ‚Çπ{annual_income:,.0f}, Expenses: ‚Çπ{annual_expenses:,.0f}, "
               f"EMIs Paid: ‚Çπ{annual_emi_paid:,.0f}. Net Saved: ‚Çπ{net_annual_income:,.0f}")
    new_state["game_log"].append(log_msg)
    
    # Check for bankruptcy
    if new_state["finances"]["savings_cash"] < 0 and not new_state["finances"]["loans"]: # Simplified check
         new_state["game_log"].append("üö® BANKRUPTCY! Your savings are depleted. Game Over.")
         new_state["game_over"] = True
         new_state["current_event"] = {"narrative": "Game Over - Bankruptcy!", "choices": []}
         return new_state


    # 3. Investment Returns (Simplified Annual Calculation)
    new_state["finances"]["investments"]["ppf"] *= (1 + INVESTMENT_RETURN_LOW_RISK)
    new_state["finances"]["investments"]["mutual_funds"] *= (1 + INVESTMENT_RETURN_MED_RISK + random.uniform(-0.05, 0.05)) # Add variability
    new_state["finances"]["investments"]["stocks"] *= (1 + INVESTMENT_RETURN_HIGH_RISK + random.uniform(-0.1, 0.1)) # Add variability
    new_state["finances"]["investments"]["digital_gold"] *= (1 + random.uniform(0.01, 0.08)) # Gold is variable

    # 4. Career Progression
    new_state["career"]["experience_years"] += 1
    if random.random() < new_state["career"].get("promotion_chance", 0.1) and new_state["finances"]["income"] > 0: # Check income > 0 (not retired/unemployed)
        old_salary = new_state["finances"]["income"]
        new_state["finances"]["income"] *= random.uniform(1.15, 1.30) # 15-30% raise
        new_state["career"]["promotion_chance"] = max(0.05, new_state["career"].get("promotion_chance", 0.1) * 0.8) # Harder next time
        new_state["game_log"].append(f"üíº Promotion! New Salary: ‚Çπ{new_state['finances']['income']:,.0f}/month (Up from ‚Çπ{old_salary:,.0f})")
    else:
        # Slight increase in promotion chance if not promoted
         new_state["career"]["promotion_chance"] = min(0.5, new_state["career"].get("promotion_chance", 0.1) * 1.1)

    # 5. Update Life Stage (Example)
    if new_state["profile"]["age"] >= RETIREMENT_AGE and new_state["life_stage"] != "Retired":
         new_state["career"]["job_title"] = "Retired"
         new_state["finances"]["income"] = new_state["finances"].get("pension", 0) # Add pension logic later
         new_state["life_stage"] = "Retired"
         new_state["game_log"].append("üå¥ Retirement Age Reached!")
         # Consider triggering retirement specific events or ending the game scenario
         # For now, let's allow playing post-retirement
         if new_state["finances"]["income"] == 0: # Basic check if no pension
              # Implement simple withdrawal logic or rely on events
              retirement_drawdown = min(new_state["finances"]["net_worth"] * 0.04, 50000 * 12) # Simplified 4% rule or max
              if new_state["finances"]["savings_cash"] < retirement_drawdown:
                   # Sell investments (simple logic: sell MF first, then Stocks)
                   needed = retirement_drawdown - new_state["finances"]["savings_cash"]
                   sold_mf = min(needed, new_state["finances"]["investments"]["mutual_funds"])
                   new_state["finances"]["investments"]["mutual_funds"] -= sold_mf
                   new_state["finances"]["savings_cash"] += sold_mf
                   needed -= sold_mf
                   if needed > 0:
                       sold_stocks = min(needed, new_state["finances"]["investments"]["stocks"])
                       new_state["finances"]["investments"]["stocks"] -= sold_stocks
                       new_state["finances"]["savings_cash"] += sold_stocks
                   new_state["game_log"].append(f"Retirement Drawdown: Moved ‚Çπ{retirement_drawdown:,.0f} to cash for expenses.")
              
              # Add drawdown to income temporarily for expense calculation to work
              # This is a simplification; better would be direct expense deduction
              # new_state["finances"]["income"] = retirement_drawdown / 12 

    elif new_state["profile"]["age"] > 50 and new_state["life_stage"] == "Mid Career":
        new_state["life_stage"] = "Late Career/Pre-Retirement"
        new_state["game_log"].append("Entering Late Career stage.")
    elif new_state["profile"]["age"] > 35 and new_state["life_stage"] == "Early Career":
         new_state["life_stage"] = "Mid Career"
         new_state["game_log"].append("Entering Mid Career stage.")
         
    # 6. Recalculate Net Worth & Health Score
    new_state = update_net_worth(new_state)
    new_state["financial_health_score"] = calculate_financial_health(new_state)

    return new_state

def call_gemini_llm(prompt, use_json_output=False):
    """ Generic function to call Google Generative AI LLM. """
    try:
        model_to_use = model_json if use_json_output else model_text
        response = model_to_use.generate_content(prompt)
        
        # Handle potential blocks or empty responses
        if not response.parts:
             if response.prompt_feedback.block_reason:
                 safety_feedback = response.prompt_feedback.safety_ratings
                 block_reason_str = response.prompt_feedback.block_reason.name
                 st.warning(f"LLM call blocked. Reason: {block_reason_str}. Feedback: {safety_feedback}")
                 return f"Error: Content blocked by safety filters ({block_reason_str})."
             else:
                 st.warning("LLM call returned no content.")
                 return "Error: LLM returned an empty response."

        result = response.text
        
        # Clean markdown formatting if JSON was expected but text was received
        if use_json_output and not result.strip().startswith('{'):
            match = re.search(r'\{.*\}', result, re.DOTALL)
            if match:
                result = match.group(0)
            else: # Failed to extract JSON
                 st.warning(f"LLM Warning: Expected JSON but failed to extract. Response:\n{result}")
                 return "Error: Failed to parse expected JSON from LLM response."

        return result

    except Exception as e:
        st.error(f"Error calling Google Generative AI API: {e}")
        # Log detailed error for debugging if needed
        # print(f"Detailed Gemini Error: {e}") 
        return f"Error: Failed to get response from LLM. Details: {e}"


def generate_llm_event(state):
    """Uses Gemini LLM to generate a life event based on current state."""
    system_prompt = """
You are the 'Event Weaver' for the Indian life simulation game 'ArthSim'.
Your task is to generate a realistic and engaging life event scenario relevant to the player's current situation in India.
The event MUST involve a financial decision.
Focus on common Indian contexts: education, career, marriage, family, health, festivals, investments (SIP, lump sum, specific schemes like PPF/NPS if relevant), loans (home, car, personal), windfalls, emergencies, etc.
Based on the player's state provided below, create an event with:
1.  A short 'narrative' description (2-4 sentences).
2.  2 to 3 distinct 'choices' (as a list of strings) the player can make. Each choice should have clear, differing financial implications (costs, investments, loans, income changes, etc.). Try to quantify costs where possible (e.g., "Cost: ‚ÇπX").

Output ONLY a valid JSON object with keys "narrative" (string) and "choices" (list of strings). Do NOT include any other text, markdown formatting, or explanations before or after the JSON object.

Example Input State (Simplified):
{ "profile": {"age": 28}, "finances": {"savings_cash": 200000, "income": 60000}, "family": {"marital_status": "Married"}, "life_stage": "Mid Career" }

Example Output (JSON):
{
  "narrative": "A long weekend is coming up! Your friends suggest a quick trip to Goa. It looks fun, but travel, stay, and expenses might cost around ‚Çπ30,000.",
  "choices": [
    "Go for it! YOLO! (Cost: ‚Çπ30,000 from savings)",
    "Suggest a cheaper local getaway instead (Cost: ‚Çπ10,000 from savings)",
    "Stay home and save the money (Cost: ‚Çπ0)"
  ]
}
"""
    # Prune state for brevity and relevance
    relevant_state = {
        "profile": state["profile"],
        "finances": {
            "savings_cash": state["finances"]["savings_cash"],
            "income": state["finances"]["income"],
            "expenses": state["finances"]["expenses"],
            "investments_total": sum(state["finances"]["investments"].values()),
            "net_worth": state["finances"]["net_worth"],
            "has_loans": bool(state["finances"]["loans"])
        },
        "career": state["career"],
        "family": state["family"],
        "life_stage": state["life_stage"],
        "assets": state["assets"]
    }
    user_prompt = f"{system_prompt}\n\nPlayer State:\n```json\n{json.dumps(relevant_state, indent=2)}\n```"

    # Use JSON mode for event generation
    event_json_str = call_gemini_llm(user_prompt, use_json_output=True)

    try:
        if isinstance(event_json_str, str) and event_json_str.startswith("Error"):
             raise ValueError(event_json_str) # Propagate error message
             
        event_data = json.loads(event_json_str) # Parse the JSON string

        if isinstance(event_data, dict) and "narrative" in event_data and "choices" in event_data and isinstance(event_data["choices"], list):
            # Add unique IDs to choices for Streamlit button keys
            choices_with_ids = []
            for i, choice_text in enumerate(event_data["choices"]):
                choices_with_ids.append({"id": f"choice_{i+1}", "text": choice_text})
            event_data["choices"] = choices_with_ids
            return event_data
        else:
            raise ValueError("Invalid JSON structure received from LLM.")

    except (json.JSONDecodeError, ValueError, TypeError) as e:
        st.error(f"LLM Error or Parsing Error generating event: {e}\nLLM Response was: {event_json_str}")
        # Fallback to a generic event
        return {
            "narrative": "A financial advisor suggests reviewing your investment portfolio. What will you do?",
            "choices": [
                 {"id": "choice_1", "text":"Invest ‚Çπ10,000 more in Medium Risk Mutual Funds"},
                 {"id": "choice_2", "text":"Hold current investments, save cash"},
                 {"id": "choice_3", "text":"Consult the AI Advisor 'ArthMitra' for advice first"}
            ]
        }

def process_decision_and_advance(state, choice_text):
    """
    Processes the player's choice, updates state, advances time, and triggers a new event.
    Returns the updated state.
    !!! This logic needs SIGNIFICANT enhancement for real gameplay !!!
    """
    if state["game_over"]: return state # Cannot make decisions if game over
    
    new_state = state.copy() # Work on a copy
    event = new_state.get("current_event")
    impact_message = f"üëâ You chose: '{choice_text}'. "

    # --- Simplified Decision Processing using Keywords ---
    cost = 0
    investment_type = None
    investment_amount = 0
    income_change = 0 # Can be positive or negative
    expense_change = 0 # Can be positive or negative (monthly)
    new_loan = None
    asset_change = {} # e.g., {"vehicle": "Car"}
    family_change = {} # e.g., {"marital_status": "Married"}

    lower_choice = choice_text.lower()

    # Helper to extract numbers (rupees)
    def extract_amount(text):
        numbers = re.findall(r'‚Çπ?([\d,]+)', text)
        if numbers:
            try:
                return int(numbers[0].replace(',', ''))
            except ValueError:
                return 0
        return 0

    # --- Example Decision Parsing (Needs Expansion) ---

    # General Cost/Savings
    extracted_cost = extract_amount(lower_choice)
    if "cost:" in lower_choice or "spend" in lower_choice or "pay" in lower_choice:
        cost = extracted_cost
    elif "save" in lower_choice and extracted_cost > 0: # If choice explicitly mentions saving an amount (opportunity cost)
        pass # No direct cost, but acknowledge the saving intent
    elif "cost: ‚Çπ0" in lower_choice or "no cost" in lower_choice or "free" in lower_choice:
        cost = 0
        
    # Investment Decisions
    if "invest" in lower_choice or "sip" in lower_choice or "lump sum" in lower_choice:
        investment_amount = extracted_cost if extracted_cost > 0 else 10000 # Default if not specified
        cost = investment_amount # Comes from savings

        if "mutual fund" in lower_choice or "medium risk" in lower_choice or "sip" in lower_choice: investment_type = "mutual_funds"
        elif "ppf" in lower_choice or "low risk" in lower_choice or "provident fund" in lower_choice: investment_type = "ppf"
        elif "stock" in lower_choice or "high risk" in lower_choice or "equity" in lower_choice: investment_type = "stocks"
        elif "gold" in lower_choice: investment_type = "digital_gold"
        else: investment_type = "mutual_funds" # Default investment

    # Buying Assets (Vehicle/Property)
    elif "buy" in lower_choice and ("car" in lower_choice or "vehicle" in lower_choice or "two-wheeler" in lower_choice or "scooter" in lower_choice):
        if new_state["assets"].get("vehicle"):
             impact_message += "You already own a vehicle. "
             cost = 0 # Prevent buying another for simplicity
        else:
            vehicle_cost = 0
            monthly_expense_increase = 0
            vehicle_type = "Vehicle"

            if "car" in lower_choice:
                vehicle_cost = extracted_cost if extracted_cost > 50000 else random.randint(400000, 800000) # Guess if not specified
                monthly_expense_increase = random.randint(4000, 8000)
                vehicle_type = "Car"
            elif "two-wheeler" in lower_choice or "scooter" in lower_choice:
                vehicle_cost = extracted_cost if extracted_cost > 10000 else random.randint(70000, 120000)
                monthly_expense_increase = random.randint(800, 1500)
                vehicle_type = "Two-wheeler"

            cost = vehicle_cost
            expense_change += monthly_expense_increase # Add to monthly expenses
            asset_change["vehicle"] = vehicle_type
            impact_message += f"Attempting to buy a {vehicle_type}. "

            # Basic Loan Logic if cannot afford full amount
            if cost > new_state["finances"]["savings_cash"]:
                down_payment = min(new_state["finances"]["savings_cash"] * 0.5, cost * 0.2) # Pay 50% cash or 20% cost as downpayment
                loan_amount = cost - down_payment
                cost = down_payment # Immediate cost is only downpayment
                
                # Simple loan calculation
                interest_rate = random.uniform(0.09, 0.14)
                loan_term_years = 5
                # Simplified EMI (more accurate formula needed for real game)
                emi = (loan_amount * interest_rate / 12) * (((1 + interest_rate / 12)**(loan_term_years * 12)) / (((1 + interest_rate / 12)**(loan_term_years * 12)) - 1)) if interest_rate > 0 else loan_amount / (loan_term_years*12)
                emi = round(emi)

                new_loan = {"principal": loan_amount, "interest_rate": interest_rate, "emi": emi, "emi_expense_impact": emi } # Track EMI impact
                loan_key = f"{vehicle_type.lower()}_loan"
                
                # Check if loan already exists (shouldn't happen with asset check, but safe)
                if loan_key not in new_state["finances"]["loans"]:
                     new_state["finances"]["loans"][loan_key] = new_loan
                     expense_change += emi # Add EMI to monthly expenses
                     impact_message += f"Paid ‚Çπ{down_payment:,.0f} down. Took a {loan_key.replace('_', ' ')} of ‚Çπ{loan_amount:,.0f} (EMI: ‚Çπ{emi:,.0f}). "
                else:
                     impact_message += "Loan processing error. " # Avoid duplicate loans
                     cost = 0 # Revert cost if loan fails
                     asset_change = {} # Revert asset change

            else: # Can afford full amount
                 impact_message += f"Paid ‚Çπ{cost:,.0f} in full. "

    # Career Decisions (Job change, education)
    elif "job" in lower_choice or "career" in lower_choice or "study" in lower_choice or "education" in lower_choice:
         if "new job" in lower_choice or "switch job" in lower_choice:
              # Simple simulation: potential salary increase but chance of temporary decrease/unemployment
              if random.random() < 0.7: # 70% chance of success
                   salary_increase_pct = random.uniform(0.1, 0.3)
                   old_salary = new_state["finances"]["income"]
                   new_salary = old_salary * (1 + salary_increase_pct)
                   income_change = new_salary - old_salary # This is monthly change
                   new_state["career"]["job_title"] = f"Senior {new_state['career']['job_title']}" # Basic title change
                   impact_message += f"Switched jobs successfully! New monthly income ‚Çπ{new_salary:,.0f} (Up by ‚Çπ{income_change:,.0f}). "
              else: # 30% chance of failure/temporary setback
                   salary_decrease_pct = random.uniform(0.05, 0.15)
                   old_salary = new_state["finances"]["income"]
                   new_salary = old_salary * (1 - salary_decrease_pct)
                   income_change = new_salary - old_salary # Negative change
                   impact_message += f"Job switch didn't go as planned. Temporary pay cut. New monthly income ‚Çπ{new_salary:,.0f} (Down by ‚Çπ{abs(income_change):,.0f}). "
         elif "study" in lower_choice or "education" in lower_choice:
              cost = extracted_cost if extracted_cost > 1000 else random.randint(50000, 200000) # Course fees
              # Potential future benefit (increase promotion chance?) - needs more logic
              impact_message += f"Investing in education (Cost: ‚Çπ{cost:,.0f}). Potential future career boost! "
              new_state["career"]["promotion_chance"] = min(0.6, new_state["career"].get("promotion_chance", 0.1) * 1.2) # Increase future chance


    # Family Events (Marriage, Children) - Very Simplified
    elif "marry" in lower_choice or "wedding" in lower_choice:
         if new_state["family"]["marital_status"] == "Single":
              cost = extracted_cost if extracted_cost > 10000 else random.randint(100000, 500000) # Wedding costs
              family_change["marital_status"] = "Married"
              # Potentially add spouse income/expenses later
              expense_change += random.randint(5000, 15000) # Increased household expenses
              impact_message += f"Got married! Significant expenses (‚Çπ{cost:,.0f}) but a joyous occasion. Household expenses increased. "
         else:
              impact_message += "You are already married. "
              cost = 0
    elif "child" in lower_choice or "baby" in lower_choice:
        if new_state["family"]["marital_status"] == "Married":
            cost = extracted_cost if extracted_cost > 1000 else random.randint(20000, 50000) # Initial costs
            family_change["children"] = new_state["family"].get("children", 0) + 1
            expense_change += random.randint(8000, 20000) # Increased monthly expenses
            impact_message += f"Welcomed a child! Initial costs (‚Çπ{cost:,.0f}) and ongoing monthly expenses increased significantly. "
        else:
            impact_message += "Maybe focus on finding a partner first? "
            cost = 0
            
    # Emergency / Windfall (Could be triggered by event narrative)
    elif event and ("emergency" in event.get("narrative", "").lower() or "unexpected expense" in event.get("narrative", "").lower()):
         cost = extracted_cost if extracted_cost > 0 else random.randint(10000, new_state["finances"]["expenses"] * 3) # Random emergency cost related to expenses
         impact_message += f"Dealing with an unexpected emergency. "
    elif event and ("windfall" in event.get("narrative", "").lower() or "bonus" in event.get("narrative", "").lower() or "inheritance" in event.get("narrative", "").lower()):
         windfall_amount = extracted_cost if extracted_cost > 0 else random.randint(20000, 100000)
         new_state["finances"]["savings_cash"] += windfall_amount # Add directly to cash
         impact_message += f"Received an unexpected windfall of ‚Çπ{windfall_amount:,.0f}! "
         cost = 0 # Windfall is income, not cost from choice


    # --- Apply Financial Changes ---
    if cost > 0:
        if new_state["finances"]["savings_cash"] >= cost:
            new_state["finances"]["savings_cash"] -= cost
            impact_message += f"Spent ‚Çπ{cost:,.0f} from savings. "
        else:
            # Insufficient funds - take emergency personal loan
            shortfall = cost - new_state["finances"]["savings_cash"]
            spent_cash = new_state["finances"]["savings_cash"]
            new_state["finances"]["savings_cash"] = 0
            impact_message += f"Insufficient funds! Spent remaining ‚Çπ{spent_cash:,.0f}. "

            # Simple high-interest personal loan
            loan_key = "personal_loan"
            interest_rate = random.uniform(0.15, 0.25)
            loan_term_years = 3
            
            # Add shortfall to existing personal loan or create new one
            if loan_key in new_state["finances"]["loans"]:
                 new_state["finances"]["loans"][loan_key]["principal"] += shortfall
            else:
                 new_state["finances"]["loans"][loan_key] = {"principal": shortfall, "interest_rate": interest_rate, "emi": 0 }

            # Update/Calculate EMI (Simplified) - Recalculate based on new total principal
            total_principal = new_state["finances"]["loans"][loan_key]["principal"]
            emi = (total_principal * interest_rate / 12) * (((1 + interest_rate / 12)**(loan_term_years * 12)) / (((1 + interest_rate / 12)**(loan_term_years * 12)) - 1)) if interest_rate > 0 else total_principal / (loan_term_years*12)
            emi = round(emi)
            
            # Add EMI to expenses if not already added or update if changed
            old_emi = new_state["finances"]["loans"][loan_key].get("emi", 0)
            expense_change += (emi - old_emi) # Add the *difference* in EMI to expense change
            new_state["finances"]["loans"][loan_key]["emi"] = emi
            new_state["finances"]["loans"][loan_key]["emi_expense_impact"] = emi # Track its contribution

            impact_message += f"Took/Increased a personal loan of ‚Çπ{shortfall:,.0f} at high interest (New EMI: ‚Çπ{emi:,.0f}). "
            new_state["financial_health_score"] = max(0, new_state["financial_health_score"] - 15) # Penalty

    if investment_type and investment_amount > 0:
        if new_state["finances"]["savings_cash"] >= investment_amount:
            new_state["finances"]["savings_cash"] -= investment_amount
            # Ensure investment type exists in dict
            if investment_type not in new_state["finances"]["investments"]:
                 new_state["finances"]["investments"][investment_type] = 0
            new_state["finances"]["investments"][investment_type] += investment_amount
            impact_message += f"Invested ‚Çπ{investment_amount:,.0f} in {investment_type.replace('_', ' ').title()}. "
        else:
            impact_message += f"Insufficient savings (‚Çπ{new_state['finances']['savings_cash']:,.0f}) to invest ‚Çπ{investment_amount:,.0f}. "
            
    # Apply Income/Expense Changes
    new_state["finances"]["income"] += income_change # Monthly
    new_state["finances"]["expenses"] += expense_change # Monthly
    if income_change != 0: impact_message += f"Monthly income changed by ‚Çπ{income_change:,.0f}. "
    if expense_change != 0: impact_message += f"Monthly expenses changed by ‚Çπ{expense_change:,.0f}. "

    # Apply Asset/Family Changes
    if asset_change:
        for key, value in asset_change.items():
            new_state["assets"][key] = value
        impact_message += f"Acquired {list(asset_change.values())[0]}. "
    if family_change:
        for key, value in family_change.items():
            new_state["family"][key] = value
        if "marital_status" in family_change: impact_message += "Marital status updated. "
        if "children" in family_change: impact_message += "Family size changed. "
            
    # Log the immediate impact
    new_state["last_decision_impact"] = impact_message
    new_state["game_log"].append(impact_message)

    # --- Advance Time & Generate Next Event ---
    new_state = advance_year(new_state)

    # Update net worth & health after changes and time advance
    new_state = update_net_worth(new_state)
    new_state["financial_health_score"] = calculate_financial_health(new_state)

    # Generate the *next* event (unless retired and no money or game over)
    if not new_state["game_over"]:
         if new_state["life_stage"] == "Retired" and new_state["finances"]["net_worth"] <= 0:
              new_state["game_log"].append("‚ö†Ô∏è Ran out of money in retirement. Game Over.")
              new_state["game_over"] = True
              new_state["current_event"] = {"narrative": "Game Over - Out of Funds in Retirement!", "choices": []}
         else:
              new_state["current_event"] = generate_llm_event(new_state)
              if new_state["current_event"] and "narrative" in new_state["current_event"]:
                   new_state["game_log"].append(f"\n‚ú® EVENT: {new_state['current_event']['narrative']}")
              else:
                   new_state["game_log"].append("Error generating next event.")
                   new_state["current_event"] = None # Clear invalid event
    
    return new_state


def get_ai_advice(state, user_query):
    """Gets advice from the Gemini LLM based on game state and query."""
    if not state:
        return "Game state is not available."

    system_prompt = f"""
You are 'ArthMitra', a friendly and knowledgeable AI financial advisor bot within the 'ArthSim' simulation game.
You are talking to {state['profile']['name']}, who is {state['profile']['age']} years old in the game.
Their current situation and the event they are facing are provided below.
Use ONLY this game context for your advice. Do NOT provide real-world financial advice.

Game Context:
Life Stage: {state['life_stage']}
Financial Health Score: {state['financial_health_score']}/100
Savings Cash: ‚Çπ{state['finances']['savings_cash']:,.0f}
Monthly Income: ‚Çπ{state['finances']['income']:,.0f}
Monthly Expenses: ‚Çπ{state['finances']['expenses']:,.0f}
Investments: {json.dumps(state['finances']['investments'])}
Loans: {json.dumps(state['finances']['loans'])}
Assets: {json.dumps(state['assets'])}
Current Event: {state.get('current_event', {}).get('narrative', 'None')}
Event Choices: {[c['text'] for c in state.get('current_event', {}).get('choices', [])]}

Your goal: Provide helpful, concise financial advice *relevant to the game situation and the user's query*.
Explain basic Indian financial concepts simply if asked (e.g., PPF, SIP, Inflation, Insurance).
Analyze the potential consequences of the current event's choices *within the game*.
Do NOT make the decision for the player. Encourage them to think about trade-offs (risk vs. reward, short-term vs. long-term).
Keep responses brief (2-5 sentences). Use Indian context (mention Rupees ‚Çπ).
"""
    user_context_prompt = f"{system_prompt}\n\nUser Query: {user_query}"

    # Use text mode for advice
    ai_response = call_gemini_llm(user_context_prompt, use_json_output=False)
    
    # Check if response indicates an error
    if isinstance(ai_response, str) and ai_response.startswith("Error"):
        return f"Sorry, I encountered an error: {ai_response}"
        
    return ai_response if ai_response else "Sorry, I couldn't generate a response right now."


# --- Streamlit UI Functions ---

def display_dashboard(state):
    """Displays the main status metrics."""
    col1, col2, col3, col4 = st.columns(4)
    col1.metric("üéÇ Age", state["profile"]["age"])
    col2.metric("üí∞ Net Worth", f"‚Çπ{state['finances']['net_worth']:,.0f}")
    col3.metric("‚ù§Ô∏è Fin Health", f"{state['financial_health_score']}/100")
    col4.metric("üè¶ Cash", f"‚Çπ{state['finances']['savings_cash']:,.0f}")

    inv_total = sum(state['finances']['investments'].values())
    loans_total = sum(loan.get('principal', 0) for loan in state["finances"]["loans"].values())

    col1a, col2a, col3a, col4a = st.columns(4)
    col1a.metric("üíº Income (Monthly)", f"‚Çπ{state['finances']['income']:,.0f}")
    col2a.metric("üí∏ Expenses (Monthly)", f"‚Çπ{state['finances']['expenses']:,.0f}")
    col3a.metric("üìà Investments", f"‚Çπ{inv_total:,.0f}")
    col4a.metric("üìâ Loans", f"‚Çπ{loans_total:,.0f}")
    
    st.progress(state['financial_health_score'] / 100)

def display_event_and_choices(state):
    """Displays the current event and decision buttons."""
    if state.get("current_event") and not state["game_over"]:
        st.subheader("Current Situation")
        st.markdown(f"**{state['current_event']['narrative']}**")
        st.markdown(f"_{state.get('last_decision_impact', '')}_") # Show impact of last choice

        st.subheader("Your Choices:")
        choices = state['current_event'].get('choices', [])
        cols = st.columns(len(choices) if choices else 1)
        for i, choice in enumerate(choices):
            cols[i].button(
                choice["text"],
                key=f"choice_btn_{choice['id']}",
                on_click=handle_decision_click,
                args=(choice["text"],) # Pass the choice text to the handler
            )
    elif state["game_over"]:
         st.error(f"**Game Over!** {state.get('current_event', {}).get('narrative', '')}")
         st.balloons()
    else:
        st.info("Click 'Start New Game' to begin!")

def display_arthmitra_chat(state):
    """Displays the AI advisor chat interface."""
    st.subheader("ü§ñ ArthMitra AI Advisor")
    
    # Display chat history
    chat_container = st.container(height=300) # Use container for scrolling
    with chat_container:
        for i, (speaker, text) in enumerate(state.get("chat_history", [])):
             if speaker == "user":
                 st.markdown(f"<div style='text-align: right; background-color: #dcf8c6; border-radius: 10px; padding: 8px; margin-bottom: 5px;'>üë§ You: {text}</div>", unsafe_allow_html=True)
             else: # AI
                 st.markdown(f"<div style='background-color: #f1f0f0; border-radius: 10px; padding: 8px; margin-bottom: 5px;'>ü§ñ ArthMitra: {text}</div>", unsafe_allow_html=True)

    # Chat Input - Use form to prevent rerun on typing
    with st.form(key="chat_form", clear_on_submit=True):
        user_query = st.text_input("Ask ArthMitra for advice:", placeholder="e.g., Explain PPF, Which choice seems safer?", key="chat_input")
        submitted = st.form_submit_button("Ask")
        if submitted and user_query:
            # Call handler directly - Streamlit reruns after this automatically
            handle_ask_arthmitra(user_query)
            # No need to manually clear, form does it. Force rerun to show update? Usually automatic.
            st.rerun() # Explicitly rerun to ensure chat history updates immediately


def display_game_log(state):
    """Displays the game log."""
    with st.expander("üìù Game Log", expanded=False):
        log_text = "\n".join(state["game_log"][::-1]) # Show newest first
        st.text_area("Log History", value=log_text, height=200, disabled=True)

# --- Streamlit Button Callback Functions ---

def start_new_game():
    """Initializes game state in session_state and gets first event."""
    st.session_state.game_state = initialize_game_state()
    # Generate the very first event
    state = st.session_state.game_state 
    # Advance year once to setup initial context before first real choice
    state = advance_year(state) 
    state["current_event"] = generate_llm_event(state)
    if state["current_event"] and "narrative" in state["current_event"]:
        state["game_log"].append(f"\n‚ú® EVENT: {state['current_event']['narrative']}")
    else:
         state["game_log"].append("Error generating first event.")
         state["current_event"] = None # Clear invalid event
    
    st.session_state.game_state = state # Save updated state


def handle_decision_click(choice_text):
    """Processes decision, advances game, updates state."""
    if 'game_state' in st.session_state:
        current_state = st.session_state.game_state
        # Disable buttons temporarily (visual cue) - Streamlit doesn't easily support disabling during callback run
        # st.spinner("Processing decision and advancing time...")
        updated_state = process_decision_and_advance(current_state, choice_text)
        st.session_state.game_state = updated_state
        # Streamlit reruns automatically after callback finishes

def handle_ask_arthmitra(user_query):
    """Handles asking the AI advisor."""
    if 'game_state' in st.session_state and user_query:
        state = st.session_state.game_state
        state["chat_history"].append(("user", user_query))
        
        # Get AI response
        with st.spinner("ArthMitra is thinking..."):
            ai_response = get_ai_advice(state, user_query)
        
        state["chat_history"].append(("ai", ai_response))
        st.session_state.game_state = state # Update state with new chat history


# --- Main Streamlit App ---

st.set_page_config(layout="wide", page_title="ArthSim India")

st.title("üáÆüá≥ ArthSim: Build Your Financial Future (Demo)")
st.markdown("Navigate life's financial decisions in India. Make choices, see consequences, and learn with your AI advisor, ArthMitra!")

# Initialize game state if it doesn't exist
if 'game_state' not in st.session_state:
    st.button("üöÄ Start New Game", on_click=start_new_game)
    st.info("Welcome! Click 'Start New Game' to begin your financial journey.")
else:
    # Game is running, display the main interface
    game_state = st.session_state.game_state

    # Top Dashboard
    display_dashboard(game_state)
    st.divider()

    # Main Game Area (Event & Choices) and AI Chat Side-by-Side
    col_main, col_ai = st.columns([2, 1]) # Main area wider

    with col_main:
        display_event_and_choices(game_state)
        st.divider()
        display_game_log(game_state)

    with col_ai:
        display_arthmitra_chat(game_state)

    st.divider()
    st.button("üîÑ Start New Game", key="restart_btn", on_click=start_new_game)

# Add some footer info
st.markdown("---")
st.caption("ArthSim Demo v0.2 | AI Powered by Google Gemini | UI by Streamlit")